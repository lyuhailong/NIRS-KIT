# 1. 创建 Contrasts的意义

对比向量（contrast vector）可用于估计信号在单个条件、多个条件的平均值或两个条件之间的幅值差（图 4.4.4）。设置对比向量的步骤：

- 1) 添加数据路径：该文件夹包含上一步模型估计后生成的所有被试的 GLM 文件；

- 2) 设置输出文件夹；

- 3) 添加对比 contrast；

	a. Name: 数据 contrast 名称

	b. Contrast Vector: 输入对比向量 contrast vector，例如“1 -1”或者“0 1 0”。
	
在 fNIRS 数据分析中，**对比向量 (contrast vector)** 用于定义不同条件下的脑部激活情况或任务效果之间的差异。`1 -1` 或者 `0 1 0` 这样的向量定义了对实验中不同条件的比较或某些条件的平均效应。

具体来说，这些对比向量的含义如下：

###  **1. `1 -1` 对比向量**
这个对比向量用于比较两个条件的差异，通常用于两种实验条件之间的直接对比。假设你有两个实验条件，例如：
- 条件 A：组词并说出来
- 条件 B：说“1，2，3”

`1 -1` 表示要对比条件 A 和条件 B：
- `1` 代表条件 A 的权重
- `-1` 代表条件 B 的权重

这样，`1 -1` 就是在计算**条件 A 和条件 B 的差异**，即你想要知道在条件 A 时的激活情况是否显著不同于条件 B。

### **2. `0 1 0` 对比向量**
这个对比向量用于在多个条件中选择特定的条件。假设你有三个实验条件：
- 条件 A
- 条件 B
- 条件 C

`0 1 0` 的意思是你只关心条件 B 的激活情况：
- `0` 代表忽略条件 A
- `1` 代表对条件 B 进行分析
- `0` 代表忽略条件 C

这样，`0 1 0` 就会计算**条件 B 的激活情况**，而不涉及条件 A 或 C。

### **对比向量的设置原则**
1. **每个数字对应设计矩阵中的一个条件**：
   对比向量中的每一个数字对应设计矩阵中的一列（每列代表一个实验条件）。正值表示该条件对激活有正贡献，负值表示该条件对激活有负贡献，0 表示忽略该条件。

2. **权重分配**：
   - `1`：表示将该条件的激活信号包含在对比中。
   - `-1`：表示将该条件的激活信号反向考虑（例如用于计算条件差异）。
   - `0`：表示忽略该条件，不纳入分析。

3. **自动补零**：
   当你没有为所有条件设置权重时，系统会自动在对比向量的右边补零。例如，对于三个条件，如果你只关心前两个条件（如 `1 -1`），系统会自动补上一个零，成为 `1 -1 0`，代表忽略第三个条件。


### 总结：
- `1 -1`：比较两个条件的激活差异，例如任务 A 和任务 B。
- `0 1 0`：只关注特定条件的激活，例如只分析条件 B 的激活情况。

选择和设置对比向量时，应基于你所关心的实验条件或任务对比。

## 对于VFT实验的设定解释

先是30秒的静息态，然后是60秒的VFT实验，然后是60秒的“1，2，3”数数，这种情况对比向量 (contrast vector) 该怎么设置？

对于这种实验设计，涉及三个阶段：**静息态** (30 秒)、**VET 实验** (60 秒) 和 **数数任务** (60 秒)，可以使用对比向量 (contrast vector) 来分析这些条件的差异。

假设你在设计矩阵中有三个条件，分别为：
1. 静息态 (Rest)
2. VET 任务 (VET)
3. 数数任务 (Counting)

### 对比向量设置方法：

1. **对比 VET 任务与静息态**：
   - 如果你想对比 VET 任务和静息态，设置对比向量为 `0 1 0`。这是因为：
     - 静息态的权重为 `0`（忽略）
     - VET 任务的权重为 `1`（关注这个条件）
     - 数数任务的权重为 `0`（忽略）

   这样，`0 1 0` 的对比向量会专注于 VET 任务和静息态之间的差异。

2. **对比数数任务与静息态**：
   - 如果你想对比数数任务和静息态，设置对比向量为 `0 0 1`。这是因为：
     - 静息态的权重为 `0`（忽略）
     - VET 任务的权重为 `0`（忽略）
     - 数数任务的权重为 `1`（关注这个条件）

   这样，你可以计算数数任务和静息态之间的差异。

3. **对比 VET 任务与数数任务**：
   - 如果你想对比 VET 任务和数数任务，设置对比向量为 `0 1 -1`。这是因为：
     - 静息态的权重为 `0`（忽略）
     - VET 任务的权重为 `1`（正向关注 VET 任务）
     - 数数任务的权重为 `-1`（负向表示数数任务）

   这样，`0 1 -1` 会对比 VET 任务与数数任务之间的激活差异。

### 总结
- **VET vs 静息态**: `0 1 0`
- **数数 vs 静息态**: `0 0 1`
- **VET vs 数数**: `0 1 -1`

这些对比向量能够帮助你在不同任务和静息态之间进行脑部激活情况的分析。

设置：可以同时设置上面的两个对比：VFTvsREST and VFTvsCOUNT， NIRS_KIT会同时计算两种情况，激活结果保存成不同的文件夹con1 and con2。
![](/Users/hailong/Desktop/截屏2024-09-16 16.34.37.png)


# 2. 分析结果解释

fNIRS数据针对单一任务态的激活分析，采用GLM法分析之后得到了beta_0和beta_1，应该选择哪个数值做进一步分析？ 哪一个是代表任务态激活的？

在 fNIRS 数据中针对单一任务态的激活分析，采用广义线性模型 (GLM) 分析之后，得到的参数 **beta_0** 和 **beta_1** 代表了模型中不同的部分：

1. **beta_0**：这个参数通常是 **截距项**，也称为基线（baseline），它代表在没有任务时（即休息态）fNIRS 信号的平均水平。它反映的是与任务无关的全局信号或背景活动。

2. **beta_1**：这个参数是与 **任务态**（task-related activity）相关的 **回归系数**。它表示在任务执行期间，与任务相关的激活对 fNIRS 信号变化的贡献。通常，beta_1 越大，说明任务态对信号的影响越强，代表了与任务态相关的血氧动力学变化。

### 应选择哪个参数进行进一步分析？

对于单一任务态的激活分析，你通常应该选择 **beta_1** 进行进一步分析，因为它反映了 **与任务相关的激活程度**。也就是说，beta_1 是任务执行期间脑区激活的指标。更具体地说：

- 如果 **beta_1 > 0**，说明任务态期间的 fNIRS 信号增加，这意味着可能有与任务相关的脑部激活。
- 如果 **beta_1 < 0**，说明任务态期间的信号减少，这可能代表抑制或任务期间的负向激活。

### 总结

在基于 GLM 分析 fNIRS 数据时，**beta_1** 是代表任务态激活的回归系数，因此应选择 **beta_1** 进行进一步分析。例如，你可以使用 beta_1 来进行组间比较、条件间比较或与行为表现相关联的分析。



# 3. NRIS_KIT数据处理代码修改说明

针对67导联数据，头动校正TDDR时间导数分布修复（Temporal Derivative Distribution Repair）因报错无法进行，采用CBSI (Cui et al., 2010): 基于相关性的信号质量提升法；但是在进行头动校正后出现很多确实值，所以在进入滤波之前添加了代码（感谢Curser）进行缺失值插补处理，添加代码的文件为`NR_filter.m` 添加代码如下：

```matlab
function nirsdata=NR_filter(nirsdata,FilterMethod,FilterModel,FilterOrder,hpf,lpf)

% Filter on the input images
%
%
% Input:
% filter_mathod:  1 = IIR; 2 = FIR; 3 = FFT.
% filter_type: 1 = high pass; 2 = low pass; 3 = bandpass.
% 
% 检查并处理非有限值
fields = {'oxyData', 'dxyData', 'totalData'};
for i = 1:length(fields)
    field = fields{i};
    data = nirsdata.(field);
    
    % 详细检查数据
    non_finite = ~isfinite(data);
    nan_values = isnan(data);
    inf_values = isinf(data);
    
    if any(non_finite(:)) || any(nan_values(:)) || any(inf_values(:))
        warning('在 %s 中发现问题值：\n非有限值: %d\nNaN值: %d\n无穷大值: %d', ...
            field, sum(non_finite(:)), sum(nan_values(:)), sum(inf_values(:)));
        
        % 尝试多种方法处理问题值
        % 1. 线性插值
        data = fillmissing(data, 'linear', 'EndValues', 'nearest');
        
        % 2. 如果还有问题，使用移动中位数填充
        if any(isnan(data(:)) | isinf(data(:)))
            data = fillmissing(data, 'movmedian', 5, 'EndValues', 'nearest');
        end
        
        % 3. 如果仍然存在问题，用列的中位数替换
        problem_indices = isnan(data) | isinf(data);
        for col = 1:size(data, 2)
            col_median = median(data(:,col), 'omitnan');
            data(problem_indices(:,col), col) = col_median;
        end
        
        % 最后检查
        if any(isnan(data(:)) | isinf(data(:)))
            warning('在 %s 中仍存在问题值，将使用全局中位数替换。', field);
            global_median = median(data(:), 'omitnan');
            data(isnan(data) | isinf(data)) = global_median;
        end
        
        nirsdata.(field) = data;
        disp(['已处理 ' field ' 中的问题值。']);
    end
end

% 最终检查
for i = 1:length(fields)
    field = fields{i};
    data = nirsdata.(field);
    if any(isnan(data(:)) | isinf(data(:)))
        error('无法完全处理 %s 中的问题值，请检查原始数据。', field);
    end
end

 % 原有的滤波代码
```

滤波设定：`FIR band pass 0.01-0.08HZ`

日立机器：Sampling Period 0.1s；任务时间60秒，任务前的时间10秒，即任务是第10-70秒之间，所以对应的scan应该是100-700。

| Pre Time[s] | 10 |
| --- | --- |
| Post Time[s] | 5 |
| Recovery Time[s] | 50 |
| Base Time[s] | 5 |

这个新机器：Sampling Period0.02s；原始数据文件没有做标记，检查后发现任务前时间30秒，即任务是第30-90秒之间，所以对应的Scan应该是1500-4500。这个任务的总时间在CH53的机器是3分30秒，在CH67的机器是2分30秒。

| Pre Time[s] | 30 |
| --- | --- |
| Post Time[s] | 60 |
| Recovery Time[s] | 60 |
| Base Time[s] | 10 |

# 4. 针对头动校正的解释：

在处理功能近红外光谱 (fNIRS) 数据的过程中，头动校正是一项重要的步骤，常用的校正方法包括 **CBSI (Correlation-Based Signal Improvement)** 和 **TDDR (Temporal Derivative Distribution Repair)**。然而，在应用这些校正方法后，可能会出现缺失值 (NA) 的情况。这通常与以下几个原因相关：

1. **校正过程中数据丢失**：由于头动校正算法会对数据进行滤波、差分等操作，一些数据点可能会被认为是异常点或噪声而被排除，从而导致缺失值。
2. **边界效应**：某些算法会在信号的起始或结束处引入缺失值（例如差分操作），这是因为在计算导数或移动平均时缺乏足够的数据点。

### 解决方案及避免缺失值的策略

1. **预处理步骤前的数据筛选和清理**：
    - **去除极端异常值**：在应用校正方法之前，可以先检测和剔除一些可能的异常值（如头动幅度特别大的时段），以减少校正过程中不必要的干扰。
    - **平滑处理**：可以在校正前先对数据进行一定程度的平滑处理，减少尖锐的信号波动，这样校正算法处理时不至于过度“修正”数据。
2. **CBSI 校正**：
    - **原理**：CBSI 校正依赖于全局信号变化的相关性，因此在一些情况下，头动产生的噪声可能与真实信号混合，导致校正后的值不合理。
    - **避免缺失值的策略**：CBSI 处理时避免过度依赖局部信号的变化，将参数设定为更宽松的范围来避免校正过程中产生 NA 值。同时，CBSI 的校正步骤本身并不会直接引入 NA 值，NA 主要出现在原始数据已经存在异常的情况下，因此确保原始数据的清洁是关键。
3. **TDDR 校正**：
    - **原理**：TDDR 校正通过计算时间导数来修正头动的影响。然而，这种方法有时会在信号的边界处或导数计算后引入 NA，特别是在短时间数据段中。
    - **避免缺失值的策略**：
        - **填充边界数据**：为避免边界处出现 NA，可以在数据的两端进行适当的填充或外推，从而避免导数计算中缺失数据点。
        - **调整窗口参数**：如果 TDDR 使用了滑动窗口方法来处理导数，确保窗口大小合适，避免窗口过小导致过度平滑或误差放大。
4. **后处理步骤：NA 值处理**：
    - **插值法处理 NA**：在校正后出现 NA 值的情况下，可以采用插值方法（例如线性插值、样条插值等）填补这些缺失点，保持数据的连续性。
    - **局部平均法**：在少量缺失值情况下，可以用邻近数据的局部平均值来替代 NA 值。
    - **剔除小片段数据**：如果某段数据存在大量 NA，可以考虑将这部分数据剔除，尤其是在该段数据不具备可分析性的情况下。
        
        ```matlab
        % 代码见上
        ```
        
5. **回顾数据集整体质量**：
    - 在进行校正之前，务必对整体数据集的质量进行评估，确保不会由于过多的运动伪影导致数据损坏严重。如果头动过于剧烈，可能需要重新采集数据。

通过这些步骤，可以减少 fNIRS 数据处理过程中因头动校正引入的 NA 值，从而获得更连续、可靠的信号数据。

# 5. 针对静息态fNRIS分析
在一个120秒的实验中，前30秒被试休息静止不动，之后60秒组词并说出来，之后30秒被试不停说“1，2，3”，这样的设计，我可以用前30秒的数据来做fNRIS静息态分析么？

在你的实验设计中，前30秒是被试静止不动的阶段，这段时间通常被认为是休息态 (resting-state) 的数据。然而，用这30秒的数据来做 fNIRS 静息态分析需要考虑以下几个关键点：

### 1. **静息态数据的时间长度**：
   - 静息态分析一般要求较长的时间窗口（通常是 5-10 分钟的静息态数据），因为静息态信号中的自发性低频波动 (例如 0.01-0.1 Hz) 是静息态功能连接分析的核心。这种低频波动需要足够长的时间段才能进行可靠的计算和分析。
   - 你提供的 30 秒时间段可能过短，无法捕捉到完整的低频波动，因此很难进行全面的静息态功能连接分析。

### 2. **静息态分析的目标**：
   - 静息态分析通常用于研究不同脑区之间在静息状态下的功能连接。然而，30秒的时间段较短，不足以提供足够的信号变化来估计可靠的连接性指标（如相关性或互信息）。
   - 如果你的分析目标仅仅是想查看在这30秒内的整体脑部活动水平变化（如血氧浓度变化），而不是做静息态连接分析，那么30秒的数据是可以的，但这不属于典型的静息态分析范畴。

### 3. **实验中任务间的对比**：
   - 在这种设计中，前30秒的静止阶段更适合作为后续60秒任务条件的基线（baseline），你可以将任务条件下的信号变化与前30秒的静息数据进行比较，而不是单独做静息态分析。
   - 你可以使用 GLM（广义线性模型）分析，设定前30秒为基线，后续60秒为任务态，从而得出任务相关的激活情况。

### 4. **静息态分析替代方案**：
   - 如果你的目标是研究静息态功能连接，可以考虑单独设计一个更长的静息态实验来收集足够的静息数据。一般来说，5-10分钟的静息态数据是比较标准的长度。
   - 在你的现有设计中，前30秒可以用于基础的基线校正，但静息态连接分析效果有限。

### 总结
尽管你的实验设计中前30秒是静止的，这段时间较短，难以进行典型的静息态 fNIRS 分析。你可以将其用于基线校正，但要进行静息态连接分析，建议收集更长的静息数据。